\section{Code Generation}
In order to print the C\# code, the AST is traversed and it is determined what code should be printed. 
Therefore the visitors (see section \ref{visitors}) are again used to to accomplish this.
The visitor used for this is the \texttt{CodeGenerationVisitor}. It is responsible for printing out the correct C\# code, such that it can be compiled and run without errors. 
The visitor uses code templates each class in the AST to insure that the code is correct. \newline
A code template is a recipe describing how the input code is converted into C\# code. 
Many templates are printed as the code is visited by the visitor. 
For example a \texttt{for}-statement first have \texttt{for (} printed, followed by a type declaration \texttt{num i = 0;}, a boolean expression \texttt{i < 10;}, an assignment statement \texttt{i = i + 1}, and a \texttt{)} at the end.\newline
For the methods in our language, we have a different solution. 
Every class for a method or constructor, see \ref{inputvalidation}, in our language must define an overload for the method \texttt{PrintGeneratedCode}. 

\begin{source}{The code printed for the squad constructor.}{}
public override string PrintGeneratedCode(string identifier, string name)
        {
            // squad one = new squad(two)
            return "squad " + identifier.ToLower() + " = new squad(" + name.ToLower() + ")";
        }
\end{source}

In the code for the \texttt{squad}-constructor, two strings are given as input. 
The first is the variable name, and the second is the input given as a string. 
A more complex example is the \texttt{agent}-constructor, which takes both a name, a rank and a team as input.

\begin{source}{The code printed for the agent constructor taking three arguments as input.}{}
public override string PrintGeneratedCode(string one, string two)
        {
            string[] input = two.Split(',');
						
            // agent one = new agent(two);
            // one.team = two
            return "agent " + one.ToLower().Trim() + 
							" = new agent(" + input[0].ToLower().Trim() + 
							", " + input[1].ToLower().Trim() + ");\n" + 
							one.ToLower().Trim() + ".team = " + 
							input[2].ToLower().Trim();
        }
\end{source}

The input string must be split up and put in the correct places, but the method still takes the same arguments as the other overloads. 
These templates are what makes it possible to print the code for any method or constructor used in our language.

\subsection{Compiling to XML}
This section follow a piece of code from it is written in MASSIVE, to the generation of a .cs file, and the final compilation of the .cs file to XML data.\\
The scenario is to create two teams with one agent on each team. The scenario can look like the source code below, when written in the MASSIVE language.

\begin{source}{MASSIVE code, creating two teams with one agent on each.}{}
main()
{
	// Creating two teams.
	new Team teamAliens("Aliens", "#FF0000");
	new Team teamRocket("Rockets", "#00CC00");
	
	// Creating two agents, rank 5 and 2, and adding them to the teams.
	new Agent Alien("Alien", 5, teamAliens);
	new Agent Rocket("Rocket", 2, teamRocket);
}
\end{source}

When the MASSIVE compiler, compiles the MASSIVE code to a .cs file, the MASSIVE compiler starts by adding some default code to the .cs file. This default code include the libraries used by the C\# compiler, to be able to compile to XML and the initialization of the lists.
\begin{source}{The default code added to the .cs file.}{}
using System; 
using System.Drawing; 
using System.Collections.Generic; 
using MASClassLibrary;

namespace MultiAgentSystem 
{ 
	class Program 
	{ 
		static void Main(string[] args) 
			{ 
				Lists.agents = new List<agent>(); 
				Lists.squads = new List<squad>(); 
				Lists.teams = new List<team>(); 
				Lists.actionPatterns = new List<actionpattern>();
\end{source}

When the default code is added, the MASSIVE compiler can add the teams and agents to the lists, which looks like this in the .cs file.
\begin{source}{The creation of the teams and agents.}{}
team teamaliens = new team("aliens", "#ff0000"); 
team teamrocket = new team("rockets", "#00cc00");

agent alien = new agent("alien", 5);
alien.team = teamaliens; 
agent rocket = new agent("rocket", 2);
rocket.team = teamrocket; 
\end{source}

To complete the .cs file the MASSIVE compiler ensures that the teams and agents are stored in the XML files by using the method \texttt{XML.generateXML()}.
\begin{source}{The method, which stores the data in the XML libraries, the output folder is a directory path.}{}
			XML.generateXML(OutputFolder);
			Console.WriteLine("XML generation complete.");
		}
	}
}
\end{source}

Finally the MASSIVE compiler call the C\# compiler, which will compile and run the .cs file and generate the XML libraries. Below is the final XML files generated by the .exe file.
\begin{source}{Teams stored in the XML file.}{}
<oldTeam>
	<id>1</id>
	<name>aliens</name>
	<color>#FF0000</color>
</oldTeam>
<oldTeam>
	<id>2</id>
	<name>rockets</name>
	<color>#00CC00</color>
</oldTeam>
\end{source}
\begin{source}{Agents stored in the XML file.}{}
<agent>
	<name>alien</name>
	<team>
		<name>aliens</name>
		<color />
		<colorStr>#ff0000</colorStr>
	</team>
	<rank>5</rank>
	<posx>0</posx>
	<posy>0</posy>
</agent>
<agent>
	<name>rocket</name>
	<team>
		<name>rockets</name>
		<color />
		<colorStr>#00cc00</colorStr>
	</team>
	<rank>2</rank>
	<posx>0</posx>
	<posy>0</posy>
</agent>
\end{source}