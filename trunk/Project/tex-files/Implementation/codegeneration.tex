\section{Code Generation}
In order to print the C\# code, the AST is traversed and it is determine what code should be printed. 
Therefore the visitors (see section \ref{visitors}) are again used to to accomplish this.
This visitor is the \texttt{CodeGenerationVisitor} and is responsible for printing out the correct C\# code, such that it can be compiled an run without errors. 
To accomplish this, code templates are used for each class in the AST. \newline
A code template is a recipe for how the input code should be converted into C\# code. 
Many templates are printed as the code is visited by the visitor. 
For example a \texttt{for}-statement first have \texttt{for (} printed, followed by a type declaration \texttt{num i = 0;}, a boolean expression \texttt{i < 10;}, an assignment statement \texttt{i = i + 1}, and a \texttt{)} at the end.\newline
For the methods in our language, we have a different solution. 
Every class for a method or constructor, see \ref{inputvalidation}, in our language must define an overload for the method \texttt{PrintGeneratedCode}. 

\begin{source}{The code printed for the squad constructor.}{}
public override string PrintGeneratedCode(string identifier, string name)
        {
            // squad one = new squad(two)
            return "squad " + identifier.ToLower() + " = new squad(" + name.ToLower() + ")";
        }
\end{source}

In the code for the \texttt{squad}-constructor, two strings are given as input. 
The first is the variable name, and the second is the input given as a string. 
A more complex example is the \texttt{agent}-constructor, which takes both a name, a rank and a team as input.

\begin{source}{The code printed for the agent constructor taking three arguments as input.}{}
public override string PrintGeneratedCode(string one, string two)
        {
            string[] input = two.Split(',');
						
            // agent one = new agent(two);
            // one.team = two
            return "agent " + one.ToLower().Trim() + 
							" = new agent(" + input[0].ToLower().Trim() + 
							", " + input[1].ToLower().Trim() + ");\n" + 
							one.ToLower().Trim() + ".team = " + 
							input[2].ToLower().Trim();
        }
\end{source}

The input string must be split up and put in the correct places, but the method still takes the same arguments as the other overloads. 
These templates are what makes it possible to print the code for any method or constructor used in our language.

\subsection{Compiling to XML}
This section follows a piece of code from the time it is first coded in MASSIVE, to the generation of a .cs file, and untill it is stored in an XML file.\\
The scenario is to create two teams with an agent on each team. This scenario can look like the source code below, when written in the MASSIVE language.

\begin{source}{MASSIVE code, creating two teams with an agent on each.}{}
main()
{
	// Creating two teams.
	new Team teamAliens("Aliens", "#FF0000");
	new Team teamRocket("Rockets", "#00CC00");
	
	// Creating two agents, rank 5 and 2, and adding them to the teams.
	new Agent Alien("Alien", 5, teamAliens);
	new Agent Rocket("Rocket", 2, teamRocket);
}
\end{source}

When the MASSIVE compiler compiles the MASSIVE code to a .cs file, the MASSIVE compiler have to always start by adding the defaults to the .cs file. These defaults include the libraries used by the C\# compiler to be able to compile to XML and the initialization of the lists.
\begin{source}{The default code added to the .cs file.}{}
using System; 
using System.Drawing; 
using System.Collections.Generic; 
using MASClassLibrary;

namespace MultiAgentSystem 
{ 
	class Program 
	{ 
		static void Main(string[] args) 
			{ 
				Lists.agents = new List<agent>(); 
				Lists.squads = new List<squad>(); 
				Lists.teams = new List<team>(); 
				Lists.actionPatterns = new List<actionpattern>();
\end{source}

When this is done the MASSIVE compiler can add the teams and agents to the lists, which looks like this in the .cs file.
\begin{source}{The creation of the teams and agents.}{}
team teamaliens = new team("aliens", "#ff0000"); 
team teamrocket = new team("rockets", "#00cc00");

agent alien = new agent("alien", 5);
alien.team = teamaliens; 
agent rocket = new agent("rocket", 2);
rocket.team = teamrocket; 
\end{source}

To complete the .cs file the MASSIVE compiler ensures that the teams and agents are stored in the XML files by using the method XML.generateXML.
\begin{source}{The method, which stores the data in the XML libraries.}{}
			XML.generateXML(@"C:\Users\Rasmus\Documents\Studier\Projekter\P4 - Multi Agent System\Project\MAS");
			Console.WriteLine("XML generation complete.");
		}
	}
}
\end{source}

Finally the MASSIVE compiler call the C\# compiler, which will compile and run the .cs file and generate the XML libraries. Below is the final XML files generated by the .exe file.
\begin{source}{Teams stored in the XML file.}{}
<oldTeam>
	<id>1</id>
	<name>aliens</name>
	<color>#FF0000</color>
</oldTeam>
<oldTeam>
	<id>2</id>
	<name>rockets</name>
	<color>#00CC00</color>
</oldTeam>
\end{source}
\begin{source}{Agents stored in the XML file.}{}
<agent>
	<name>alien</name>
	<team>
		<name>aliens</name>
		<color />
		<colorStr>#ff0000</colorStr>
	</team>
	<rank>5</rank>
	<posx>0</posx>
	<posy>0</posy>
</agent>
<agent>
	<name>rocket</name>
	<team>
		<name>rockets</name>
		<color />
		<colorStr>#00cc00</colorStr>
	</team>
	<rank>2</rank>
	<posx>0</posx>
	<posy>0</posy>
</agent>
\end{source}