\chapter{MASSIVE Language}
\label{usecase}

In this report we illustrates how we designed and implemented the agent oriented language, MASSIVE. During this chapter we demonstrates a working simulation with a use case, and compare the agent oriented language to Object Oriented Code (C\#). Furthermore we discuss the advantages and disadvantages of the MASSIVE language. 

\section{Use Case}
In this use case we demonstrate how to write a mini-game in our language, how to compile it and how to play it. \\
 \\
The first thing one needs to do is to write some MASSIVE code. In \ref{code:MASSIVE} is examples of code, however, there are features of the langauge that are not being used in this example. For a full code referernce please check \ref{} HEJ MED DIG. In the example two teams are created called "Disco" and "Kman", agents are added to them and at the end a simple action pattern is defined, later to be used when running the simulation.

\begin{source}{MASSIVE code example \label{code:MASSIVE}}{}

/* Initializes the game with the properties
Maximum Units = 400 */
Main ( 400 )
{	
	
	// Creates team Disco.
	new team teamDisco("Disco", "#FF6600");
	num totalDiscos = 10;
	for ( num i = 0; i < totalDiscos; i = i + 1)
	{
		num a = 0;
		if ( i < totalDiscos-1 )
		{
			a = 1;
		}
		else
		{
			a = 21-totalDiscos;
		}
		
		new Agent newAgent("Stue", a);
		teamDisco.add(newAgent);
	}
	
	new team teamKman("Kman", "#660000");
	new squad squadNabs("noobs");
	new squad squadRevo("Revolution");
	
	for(num i = 0; i < 4; i = i + 1)
	{
		num a = 0;
		if(i =< 1)
		{
			a = 2;
		}
		if(i >= 2)
		{
			a = 8;
		}
		
		new Agent newAgent("Kman", a);
		teamKman.add(newAgent);
		
		if (i <= 1)
		{
			squadNabs.add(newAgent);
		}
		if (i => 2)
		{
			squadRevo.add(newAgent);
		}
	}
	
	// Moves used in the actionPatterns.
	string moveUp = "unit move up";
	string moveDown = "unit move down";
	string moveLeft = "unit move left";
	string moveRight = "unit move right";
	
	// Creates the action pattern Patrol Low.
	// Patrols the lower part of the game area.
	new actionpattern patrolLow("PatrolLow");
	patrolLow.add(moveUp);
	patrolLow.add("unit move 25,24");
	patrolLow.add(moveUp);
	patrolLow.add("unit move 0,23");
	patrolLow.add(moveDown);
	
}
\end{source}{}{}
When compiling this code the compiler warns that there are unused variable (see \ref{fig:compiler}). We will disregard this for the purpose of this use case, however, if there were serious faults in the code the compiler would warn you the same manner and maybe even refuse to compile if the faults were serious enough.

\begin{figure}[h]%
\begin{center}
\includegraphics[width=\columnwidth]{Images/compiler.png}%
\caption{The MASSIVE compiler warning of unused variables.}%
\label{fig:compiler}%
\end{center}
\end{figure}

The compiler will happily compile the code again if that option is selected, which provides the programmer with an easy way of correcting erroneous code. After a succesfull compilation a file named "MASSIVECode.cs"and "MASSIVECode.exe" will have been created. The only purpose of creating the cs-file is allowing the programmer to have a look at the code our compiler generates. The cs-file will have been compiled into the exe-file wich is run automatically. This exe-file creates the actual data output in XML format, which is then run by the MASSIVE simulator, and the user of the simulator is given a choice of how large the game grid will be (see \ref{fig:game_promt}).

\begin{figure}[h]%
\begin{center}
\includegraphics[width=\columnwidth]{images/massive_dialog.png}%
\caption{Choosing the size of the game-grid}%
\label{fig:game_promt}%
\end{center}
\end{figure}

Upon choosing "large", the user will bee presented with the actual simulation (see \ref{fig:runninggame}). Here he will have the oppertunity to instruct the agents to use the action pattern defined in \ref{code:MASSIVE}, as shown in \ref{fig:runninggame}.

\begin{figure}%
\begin{center}
\includegraphics[width=\columnwidth]{Images/massive_small.png}%
\caption{The simulation running with the input instructing som of the agents to use an actionpattern}%
\label{fig:runninggame}%
\end{center}
\end{figure}

At this point the user is presented with a choice; He can either press "Simulate" to let the simulation run to an end without any interaction, or he can choose to run the game turn-by-turn and control the agents as the game progresses. We see the result of this simulation in \ref{fig:winner}.

\begin{figure}%
\begin{center}
\includegraphics[width=\columnwidth]{Images/massive_patrollow.png}%
\caption{The result of the use case simulation in MASSIVE}%
\label{fig:winner}%
\end{center}
\end{figure}

\section{Comparison}
\indent This section is about how to make a multi agent wargame in C\# compared to our own language MASSIVE. We will take a look on some of the pros and cons by using C\# to build a multi agent wargame, aswell as the pros and cons while using MASSIVE. We will then compare C\# and MASSIVE to examine which language is the best to build a multi agent wargame.

\section{C\#}
C\# is a object orientated language(OOP) that we have decided to compare MASSIVE with, we decided to use C\# to compare with because both our compile and enviroment are written in this language. C\# do not have built in functions or enviroment multi agent orientated, which means it is required for the programmer to build the multi agent wargame from scratch. To build a basic multi agent wargame in C\# you need to make constructors for agent and teams, furthermore you will also need to create functions for agents and teams, which might be movement, attack, and attack functions. At last you will need to create an enviroment where the agents and teams will simulate a wargame. However building a multi agent wargame in C\# enables you to create all the features you want in a wargame simulation.

Using C\# you can declare objects and use them later.

Pros
-No limits, you can create all the features you want.
Cons
-No existing multi agent enviroment.
-No existing multi agent constuctors.
-No existing multi agent functions.

\section{MASSIVE}
MASSIVE is a agent orientated language(AOL) which contains premade enviroment and functions for creating agents, squads, teams, and actionpatterns, which means that you do not have to make this yourself. It is relative fast to simulate a wargame in MASSIVE, since all the function you need is already made. You cannot declare new functions in MASSIVE which limit you to only use the built in functions. MASSIVE is not case sensitve. When declaring an object in MASSIVE you are forced to declare it with properties.

Pros
-Relative fast to simulate a wargame.
-Premade enviroment.
-Premade constructors for agent, squad, team, actionpattern.
-Not case sensitive
Cons
-Limited to the languages functions.

%Good and abd things about MASSIVE
%Why is our MASSIVE better than OOP. 
\section{C\# vs MASSIVE}
In this section we will compare C\# and MASSIVE, we assume that we have already created constuctors, functions, and an enviroment for the C\# code.

\begin{source}{C\# ActionPattern code example}{}                    
static void Main(string[] args)
    {
        ActionPattern AP = new ActionPattern("unit move up");
    }
\end{source}

\begin{source}{MASSIVE ActionPattern code example}{}                    
	Main(400)
	{
	new ActionPattern ap("Action1");
	ap.add("unit move up");
	ap.add"unit move left");
	ap.add("unit move up");
	}
\end{source}

\begin{source}{C\# Teams code example}{}                    
	
\end{source}

\begin{source}{MASSIVE Teams code example}{}                    
	Main(
\end{source}

\begin{source}{C\# Agent code example}{}                    
	
\end{source}

\begin{source}{MASSIVE Agent code example}{}                    
	Main(400)
	{
	new Agent derp(
	}
\end{source}

\begin{source}{C\# Squad code example}{}                    
	
\end{source}

\begin{source}{MASSIVE Squad code example}{}                    
	
\end{source}

% Her skal vi vise nogle eksempler på at det er bedre at bruge vores sprog end eksempelvis C\#.
