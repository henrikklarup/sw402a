\section{Semantics}
\label{sec:semantics}

The semantics of a programming language is a mathematical notation that explains langauge behavior. 
It defines the behaviour of all the elements in a language \cite{misc:sem}.\\ \indent
The semantics of the language $Bims$, and various extensions of it, are used as an example. 
The first part of the language semantics are the syntactic categories, which define the different syntactic elements in the language.

\begin{itemize}
\item Numeric values $n \in$ Num.
\item Variables $v \in$ Var.
\item Arithmetic expressions $a \in$ Aexp.
\item Boolean expressions $b \in$ Bexp.
\item Statements $S \in$ Stm.
\end{itemize}

The next part of the semantics are the formation rules. 
These rules define the different operations that can be executed in the language. 
Here are the rules for statements: \newline

$S ::= x := a$ $|$ \texttt{skip} $|$ $S_1;S_2$ $|$ \texttt{if} $b$ \texttt{then} $S_1$ \texttt{else} $S_2$ $|$ \texttt{while} $b$ \texttt{do} $S$\newline

These rules define what kind of transitions can be done in the language. 
A transition happens when an operation is executed, and the program is moved into its next configuration. 
All transitions and configurations are defined by a transition system, which consists of three things. 

\begin{itemize}
\item $\Gamma$ represents all possible configurations. 
\item $\rightarrow$ represents all possible transitions.
\item $T$ represents the terminal configurations, which are the configurations with no transitions leading away from them.
\end{itemize}

The environment-store model is a way of storing variables, and it is used to store variables in the semantics. \newline
The model consists of a variable environment and a store function. 
The variable environment is the environment where variables are referenced, mimicking memory addresses in a computer. 
The store function then uses the reference to find the actual value of the variable. \newline

Finally, bigstep semantics are used to describe the different transition rules. 
Bigstep semantics represent transitions with a one to one mapping. 
The opposite of this is the smallstep semantic, where each transition has several semantic steps described, but will not be described further.\newline

The first example is the bigstep transition rule for declaring a variable. 
    \begin{tabular}{ll}
                \mbox{} & \hspace{8cm} \\
                \hline
                \runa{VAR-DECL} & \infrule{\lag D_v, env''_v, sto[l \mapsto v] \rag \rightarrow_{DV} (env'_v, sto')}
								{\lag var \mbox{}\; x \mbox{}\; := \mbox{}\; a; \mbox{}\; D_v, env_v, sto \rag \rightarrow_{DV} (env'_v, sto')}
                 \\
                & $\mbox{where}\; env_{v}, sto \vdash a \rightarrow_a v$ \\
								& $\mbox{and}\; l = env_v \mbox{ next}\;$ \\
								& $\mbox{and}\; env''_v = env_v[x \mapsto l][\mbox{next}\; \mapsto \mbox{new}\; l]$ \\
& \\
                \hline
        \end{tabular}
\newline
This transition rule expects one variable declaration to be followed by another. 
This next declaration can then either be empty, in order to end all the declarations, or a new variable declaration. 
That is what the $D_v$ in the conclusion of the rule means. \newline
The conclusion of the rule is what is written below the line, where the premises of the rule are the things that are written above the line. 
These are the premises the transition will happen under. 
This means the variable declaration will end with the environment being updated with the next available location $l$ being set to the value $v$, which is the value contained in $a$.\newline
The $next$ location in the environment refers to the next available location, while $new$ refers to the neighbour of any variable given to it.\newline
Furthermore, we will be using dynamic scope rules, which means all variables are available in scopes opened after they are declared.