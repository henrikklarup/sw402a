\section{Scanner}
\label{sec:scannertheory}
The scanner's purpose is to recognize tokens in the source program. Tokens are abstractions of the code, and the scanner simplifies the code by recognising a string as a token. For example might a \+ be recognised as an OPERATOR token. This process is called \textit{lexical analysis} and is a part of the \textit{syntactic analysis}.
\\
\\
Terminal symbols are the individual characters in the code, which the scanner reads and creates an equivalent token for \cite{misc:spo}. The source program contain separators, such as blank spaces and comments, which separate the tokens and make the code readable for humans. Tokens and separators are nonterminal symbols.
\\
\\
The development of the scanner can be divided into three steps:
\begin{enumerate}
\item The lexical grammar is expressed in EBNF \ref{sec:ebnf}.
\item For each EBNF production rule $N::=X$, a transcription to a scanning method \texttt{scanN} is made, where the body is determined by $X$.
\item The scanner needs the following variables and methods: 
\begin{enumerate}
\item \texttt{currentChar}, which holds the currect character to scan.
\item \texttt{take()}, which compares the current character to an expected character.
\item \texttt{takeIt()}, which updates the current character to the next character in the string.
\item \texttt{scanN()}, as seen in step 2, though improved so it records the kind and spelling of the token as well.
\item \texttt{scan()}, which scans the combination 'Separator* Token', discarding the separator and returning the token.
\end{enumerate}
\end{enumerate}

See more about the BNF and EBNF notation in section \ref{sec:ebnf} and see the full implementation of the grammar in the appendix \ref{ap:fullgrammar}.