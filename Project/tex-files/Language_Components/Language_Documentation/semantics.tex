\section{Semantics}
The transition rules for MASSIVE are operational semantics written in bigstep notation. 
See section \ref{sec:semantics} for more theory on semantics. \newline

In this section there will be a description of the transition rules for some of the transitions in MASSIVE. 
First the transition system for commands is shown. \newline

\begin{tabular}{l}
$\Gamma_{COM} = EnvV \times Sto$\\
$T_{COM} = EnvV \times Sto$
\end{tabular}
\newline

Because commands can transition into any available state and any command can be the last command in the code, all combinations of sto and EnvV are possible transitions. \newline

The first transition demonstrated is the one that happens in an if command. 
This requires two separate transitions, because the if command can behave in different ways depending on the input. \newline
The first transition is for an if command with no \texttt{else} block attached, where the expression it is given to evaluate, evaluates to true. \\

    \begin{tabular}{ll}
                \mbox{} & \hspace{8cm} \\
                \hline
                \runa{IF-TRUE} & \infrule{env_v \vdash \lag S_1, sto \rag \rightarrow sto'}
								{env_v \vdash \lag \mbox{\tt if (b)}\; \{ S_1 \}, sto \rag \rightarrow sto'}
                 \\
                & $\mbox{if}\; env_{v}, sto \vdash b \rightarrow tt$ \\
& \\
                \hline
        \end{tabular}
				
If the boolean value $b$ evaluates to true, then this transition happens. 
The execution of $S_1$ leads to sto being altered, because $S_1$ can change the values of any variables in the variable environment. \newline
If instead $b$ evaluates to false, and it has an \texttt{else} block, the transition rule looks like this:\newline

    \begin{tabular}{ll}
                \mbox{} & \hspace{8cm} \\
                \hline
                \runa{IF-ELSE-FALSE} & \infrule{env_v \vdash \lag S_2, sto \rag \rightarrow sto'}
								{env_v \vdash \lag \mbox{\tt if (b)}\; \{ S_1 \} \mbox{\tt  else}\; \{ S_2 \}, sto \rag \rightarrow sto'}
                 \\
                & $\mbox{if}\; env_{v}, sto \vdash b \rightarrow ff$ \\
& \\
                \hline
        \end{tabular}
				
Here the premise only has $S_2$ and not $S_1$ to alter sto with. 
This is because $b$ will evaluate to false, and $S_1$ will never be evaluated, and therefor not have any effect on the environment. \newline
Next we look at the method for adding an agent to a squad. 
The method for adding an agent to a squad comes built into the language. 
Storing this result alters the squad by adding the agent to it. \newline

    \begin{tabular}{ll}
                \mbox{} & \hspace{8cm} \\
                \hline
                \runa{ADD-AGENT-SQUAD} & \infrule{env_v \vdash \lag s, a, sto \rag \rightarrow s', sto'}
								{env_v \vdash \lag \mbox{\tt s.add(a)}\;, sto \rag \rightarrow s', sto'}
& \\
                \hline
        \end{tabular}
				\newline
This transitions uses an agent $a$ and a squad $s$, and adds $a$ to $s$, which leads to both $s$ and sto being altered.\\
The next example is the string declaration, which can add new variables to the environment. 
Therefore, new transitions are needed for the available transtions of the program. 
\newline

\begin{tabular}{l}
$\Gamma_{DS} = (DecS \times EnvV \times Sto)\mbox{}\; \bigcup \mbox{}\;(EnvV \times Sto)$\\
$T_{DS} = EnvV \times Sto$
\end{tabular}

    \begin{tabular}{ll}
                \mbox{} & \hspace{8cm} \\
                \hline
                \runa{STRING-DECL} & \infrule{\lag D_s, env''_v, sto[l \mapsto s] \rag \rightarrow_{} (env'_v, sto')}
								{\lag string  x = s; env_v, sto \rag \rightarrow_{} (env'_v, sto')}
                 \\
                & $\mbox{where}\; env_{v}, sto \vdash s \rightarrow_s v$ \\
								& $\mbox{and}\; l = env_v \mbox{ next}\;$ \\
								& $\mbox{and}\; env''_v = env_v[x \mapsto l][\mbox{next}\; \mapsto \mbox{new}\; l]$ \\
& \\
                \hline
        \end{tabular}
				\newline
				
The last transition demonstrated, is the declaration of an actionpattern. 
An actionpattern needs a name when it is created, which is handled seperately as a string declaration. 

\begin{tabular}{l}
$\Gamma_{DAP} = (DecAP \times EnvV \times Sto)\mbox{}\; \bigcup \mbox{}\;(EnvV \times Sto)$\\
$T_{DAP} = EnvV \times Sto$
\end{tabular}
				
				    \begin{tabular}{ll}
                \mbox{} & \hspace{8cm} \\
                \hline
                \runa{AP-DECL} & \infrule{\lag D_{ap}, D_s, env''_{v}, sto[l \mapsto ap] \rag \rightarrow_{} (env'_{v}, sto')}
								{\lag \mbox{new}\; \mbox{actionpattern}\; \mbox{ap}(name), env_{v}, sto \rag \rightarrow_{} (env'_{v}, sto')}
                 \\
                & $\mbox{where}\; env_{v}, sto \vdash ap \rightarrow_{ap} v$ \\
								& $\mbox{and}\; D_{s} \vdash name \rightarrow_s ap.name$\\
								& $\mbox{and}\; l = env_{v} \mbox{ next}\;$ \\
								& $\mbox{and}\; env''_{v} = env_{v}[x \mapsto l][\mbox{next}\; \mapsto \mbox{new}\; l]$ \\
& \\
                \hline
        \end{tabular}