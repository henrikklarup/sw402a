\section{Grammar}
\label{sec:ebnf}

BNF (Backus-Naur Form) is a formal notation technique used to describe the grammar of a context-free language \cite{misc:ss}. There are several variations of BNF, for example Augmented Backus-Naur Form (ABNF\footnote{ABNF has been popular among many
   Internet specifications. ABNF will not be further expanded on in this project.}) and Extended Backus-Naur Form (EBNF). EBNF is used to describe the grammer of the language developed in this project \cite{misc:spo}.\\
\\
The EBNF is a combination of BNF and regular expressions (REs, see table \ref{tab:re}), and combines advantages of both regular expressions and BNF. The expressive power in BNF is retained while the use of regular expression notation makes specifying some aspects of syntax more convenient.

\begin{center}
	\begin{table}[H]
    \begin{tabular}{ | l | l | p{6.5cm} |}
    \hline
     & Regular expression & Product of expression\\ \hline
    empty & $\varepsilon$ & The empty string.\\ \hline
    singleton & $t$ & The string consisting of $t$ alone.\\ \hline
    concatenation & $X \cdot Y$ & The concatenation of any string generated	by $X$ and any string generated by $Y$.\\ \hline
		alternative & $X$|$Y$ & Any string generated either by $X$ or $Y$.\\ \hline
		iteration & $X^*$ & Any string generated either by $X$ or $Y$.\\ \hline
		grouping & $(X)$ & Any string generated by $X$.\\ \hline
    \end{tabular}
		\caption{Table of regular expressions \cite{misc:spo}. $X$ and $Y$ are arbitrary REs, and $t$ is any terminal symbol.}
		\label{tab:re}
	\end{table}
\end{center}

Here are a few examples of the use of REs: \\
\textbf{A B} | \textbf{A C} generates \textbf{{AB, AC}} \\
\textbf{A} (\textbf{B} | \textbf{C}) generates \textbf{{AB, AC}} \\
\textbf{A$^*$ B} generates \textbf{{B, AB, AAB, AAAB, ...}} \\

In order to make the grammar easier to implement in the compiler, the left factorization techniques can be utilized.

\subsubsection*{Left Factorization}
Given that we have choices on the form $A B$ | $A C$, where $A$, $B$ and $C$ are arbitrary extended REs, then we can replace these alternatives with the corresponding extended RE: $A (B | C)$. These two expressions are said to be equivalent because they generate the exact same languages.

\subsubsection*{Elimination of Left Recursion}
Here is an example of how left recursion can be eliminated with EBNF. If we have a BNF production rule $N ::= X | N Y$, where $N$ is a nonterminal symbol, and $X$ and $Y$ are arbitrary extended REs, then we can replace this with an equivalent EBNF production rule: $N ::= X (Y)^*$. These two rules are said to be equivalent because they generate the exact same language.

\subsubsection*{Substitution of Nonterminal Symbols}
In an EBNF production rule $N::=X$ we can substitute $X$ for any occurrence of $N$ on the right-hand side on another production rule. If we do this, and if $N::=X$ is nonrecursive where this rule is the only rule for $N$, then we can eliminate the nonterminal symbol $N$ and the rule $N::=X$.\\ \indent
Whether or not such substitution should be made is a matter of convenience. If $N$ is only represented a few times, and if $X$ is uncomplicated, then this specific substitution might simplify the grammar as a whole.

\subsubsection*{Starter Sets}
The starter set of a regular expression $X$ (\textit{starters[[$X$]]}) is the set of terminal symbols that can start a string generated by $X$. As an example, we have the type starters $n | N | s | S | b | B$, where the types are \texttt{num}, \texttt{string} and \texttt{bool}. Since the starters are case insensitive, we have both the uppercase and lowercase letters in the starter set for type. The full starter set overview can be found in appendix \ref{ap:starters}.