\chapter{Goal of the product}

Our goal is to create a language that can express agents in some shape or form, we call this an Agent Oriented Language (AOL). Before that can be done however, we need to clarify what type of system we would like to build. We are not creating a MAS like the ones demonstrated\ref{sec:environments}, but rather a form of wargame.\\
\indent The programmer should, using our programming language, be able to express agents and predefine behaviors for these. The player of the game should then be able to choose whether to use the predefined behavior, or take control of the agent himself. Both the programmer and the player should be able to define the behavior of an agent when it come close to other hostile agents. \\

\section{Rules}
Our wargame scenario should be very simple;
\begin{itemize}
	\item The game is turn-based
	\item The game is played on a grid-like map
	\item Each agent can move three grid-points in each turn
	\item A higher ranked agent have a higher chance of winning
	\item Agents fight when they are standing on the same grid-point
\end{itemize}

To get an overview of how the game operates, the layout of a game round is added in psuedocode.

\begin{source}{Game Round}{}
function gameRound()
{
	gameFrame();
	EndTurn();
}
\end{source}

The two functions called in the gameRound function, can be seen below.

\begin{source}{Game Frame}{}
for(i = 0; i <= 3; i = i + 1)
{
	//Check for encounters
	foreach(agent a in agents)
	{
		if(a is within bounderies of another agent)
		{
			a.RemoveAllMovements();
			a.encounter.Compile();
		}
	}	

	//Random movement if non
	foreach(agent a in agents)
	{
		if(a has no movement)
		{
			agent moveToAgent = getRandomAgent();
			a.MoveToAgent(moveToAgent);
		}
	}

	//Check if the list is empty
	if(moveAgents contains no items)
		return;

	//Update agent positions
	foreach(agent a in agents)
	{
		if(a.team == currentteam)
		{
			foreach(agent moveAgent in moveAgents)
			{
				a.CalculateNextPosition();
				if(a.NextPosition.IsInBounds())
				{
					a.MoveAgent();
				}
				if(a.IsAtEndPosition())
				{
					moveAgents.Remove(a);
				}
			}
		}
	}


	//Check for collision
	for(agentCount = 0; agentCount < agnets.TotalAgents; agentCount++)
	{
		foreach(agent a in agents)
		{
			if(a.CollideWithAgentOnOtherTeam())
			{
				if(a.Roll > CollidedAgent.Roll)
				{
					agents.Remove(CollidedAgent);
				}
				else
				{
					agents.Remove(a);
				}
			}
		}
	}
}

\end{source}

\begin{source}{End turn}{}
if(only team 1 has agents)
{
	Team 1 wins!
}

...

else if(only team n has agents)
{
	Team n wins!
}

else
{
	switchTurn();
}
\end{source}