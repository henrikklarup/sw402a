\section{Code Generation}
In order to print the C\# code, we traverse the AST and determine what code should be printed. 
Therefore the visitors (see section \ref{visitors}) are again used to to accomplish this.
This visitor is the \texttt{CodeGenerationVisitor} and is responsible for printing out the correct C\# code, such that it can be compiled an run without errors. 
To accomplish this, code templates are used for each class in the AST. \newline
A code template is a recipe for how the input code should be converted into C\# code. 
Many templates are printed as the code is visited by the visitor. 
For example a \texttt{for}-statement first have \texttt{for (} printed, followed by a type declaration \texttt{num i = 0;}, a boolean expression \texttt{i < 10;}, an assignment statement \texttt{i = i + 1}, and a \texttt{)} at the end.\newline
For the methods in our language, we have a different solution. 
Every class for a method or constructor, see \ref{inputvalidation}, in our language must define an overload for the method \texttt{PrintGeneratedCode}. 

\begin{source}{The code printed for the squad constructor.}{}
public override string PrintGeneratedCode(string one, string two)
        {
            // squad one = new squad(two)
            return "squad " + one.ToLower() + " = new squad(" + two.ToLower() + ")";
        }
\end{source}

In the code for the \texttt{squad}-constructor, two strings are given as input. 
The first is the variable name, and the second is the input given as a string. 
A more complex example is the \texttt{agent}-constructor, which takes both a name, a rank and a team as input.

\begin{source}{The code printed for the agent constructor taking three arguments as input.}{}
public override string PrintGeneratedCode(string one, string two)
        {
            string[] input = two.Split(',');
						
            // agent one = new agent(two);
            // one.team = two
            return "agent " + one.ToLower().Trim() + 
							" = new agent(" + input[0].ToLower().Trim() + 
							", " + input[1].ToLower().Trim() + ");\n" + 
							one.ToLower().Trim() + ".team = " + 
							input[2].ToLower().Trim();
        }
\end{source}

The input string must be split up and put in the correct places, but the method still takes the same arguments as the other overloads. 
These templates are what makes it possible to print the code for any method or constructor used in our language.