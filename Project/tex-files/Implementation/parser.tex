\section{Making the Parser}
The parser (see section \ref{sec:parser}) takes the stream of tokens and keywords generated by the scanner and builds an abstract syntax tree (see section \ref{sec:asttheory}) from it, while also checking for grammatical correctness.
To accomodate all the different tokens, each token has a unique parsing method, that is called whenever a corresponding token is checked.
Each of these methods then generate their own subtree that is added to the AST. \\

\begin{source}{This is the main parsing method, which parses a mainblock and returns it as the AST.}{}
public AST parse()
        {
            return parseMainblock();
        }
\end{source}
\begin{source}{This method parses a mainblock and returns a mainblock object, consisting of all subtrees created by the underlying parsing methods.}{}
private AST parseMainblock()
        {
            Mainblock main;

            accept(Token.keywords.MAIN);
            accept(Token.keywords.LPAREN);
            Input input = (Input)parseInput();
            accept(Token.keywords.RPAREN);
            main = new Mainblock(parseBlock());
            accept(Token.keywords.EOT);

            main.input = input;

            return main;
        }
\end{source}
In the parseMainblock example, we see that it returns a Mainblock object (which inherits from the AST class) called main. 
The constructor for the Mainblock takes a Block object as its input, so main is instantiated with a parseBlock call. \\
The parser checks for grammatical correctness, by checking if each token is of the expected type. 
For example, a command should always end with a semicolon, so the parser checks for a semicolon after each command. 
If there isn't one, the parser returns an error saying what line the error was on, and which token did not match an expected token.