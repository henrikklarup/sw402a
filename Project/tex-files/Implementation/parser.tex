\section{Making the Parser}
The parser (see section \ref{sec:parser}) takes the stream of tokens and keywords generated by the scanner, and builds an abstract syntax tree (see section \ref{sec:asttheory}) from it, while also checking for grammatical correctness.
To accomodate all the different tokens, each token has a unique parsing method, which is called whenever a corresponding token is checked.
Each of these methods then generate their own subtree which is added to the AST. \\

\begin{source}{This is the main parsing method, which parses a mainblock and returns it as the AST.}{}
public AST parse()
        {
            return parseMainblock();
        }
\end{source}
\begin{source}{This method parses a mainblock and returns a mainblock object, consisting of all subtrees created by the underlying parsing methods.}{}
private AST parseMainblock()
        {
            Mainblock main;

            accept(Token.keywords.MAIN);
            accept(Token.keywords.LPAREN);
            Input input = (Input)parseInput();
            accept(Token.keywords.RPAREN);
            main = new Mainblock(parseBlock());
            accept(Token.keywords.EOT);

            main.input = input;

            return main;
        }
\end{source}
In the \texttt{parseMainblock} example, we see that it returns a \texttt{Mainblock}-object, which inherits from the AST class, called \texttt{main}. 
The constructor for the \texttt{Mainblock} takes a \texttt{Block}-object as its input, so \texttt{main} is instantiated with a \texttt{parseBlock}-call. \\
The parser checks for grammatical correctness by checking if each token is of the expected type. 
For example, a command should always end with a semicolon, so the parser checks for a semicolon after each command. 
If there is no semicolon, the parser returns an error together with the line number and token which did not match an expected token.