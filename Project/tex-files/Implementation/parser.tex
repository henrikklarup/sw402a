\section{Making the Parser}
The parser is what takes the compilation of tokens and keywords generated by the scanner and builds an abstract syntax tree (AST) from it (while also checking for grammatical correctness).
To accomodate all the different tokens, each token has a unique parsing method, that is called whenever a corresponding token is checked. 
Each of these methods then generate their own subtree of the AST, and returns that subtree, so it can be added to the AST. \\
For details on how the AST works, see section \ref{AST}.

\begin{source}{This is the main parsing method, which parses a mainblock and returns it as the AST.}{}
public AST parse()
        {
            return parseMainblock();
        }
\end{source}
\begin{source}{This method parses a mainblock and returns a mainblock object, consisting of all subtrees created by the underlying parsing methods.}{}
private AST parseMainblock()
        {
            Mainblock main;
            switch(currentToken.kind)
            {
                case (int)Token.keywords.MAIN:
                    acceptIt();
                    accept(Token.keywords.LPAREN);
                    accept(Token.keywords.RPAREN);
                    main = new Mainblock(parseBlock());
                    accept(Token.keywords.EOT);
                    return main;
                default:
                    // Error message
                    accept(Token.keywords.ERROR);
                    return null;
            }
        }
\end{source}
In the parseMainblock example, we see that it returns a Mainblock object (which inherits from the AST class) called main. 
The constructor for the Mainblock takes a Block object as its input, so main is instantiated with a parseBlock call. \\
The parser checks for grammatical correctness, by checking if each token is of the expected kind. 
For example, a command should always end with a semicolon, so the parser checks for a semicolon after each command. 
If there isn't one, the parser returns an error saying what line the error was on, and which token did not match an expected token.